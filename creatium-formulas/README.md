# Creatium Expression

Язык выражений, одинаково выполняемый в PHP, MongoDB и JS.

## Особенности языка

Синтаксис как у JS, но поведение как у выражений MongoDB. Важные особенности:

- Статическая типизация с явным приведением типов
- Отсутствует NaN, вместо него исключения кидаются
- Отсутствует undefined и missing, вместо них null
- Сравнение объектов всегда глубокое, а не просто по ссылке
- Доступ к последнему массива через arr[-1]
- Монга пустую строку считает за true в условиях, а мы за false
- Чтение несуществующих переменных и свойств бросает ошибку

## Тестирование

В файле test/config.js нужно указать доступ к монге и актуальный путь до PHP версии 7.4 или выше.

Mongo должна быть не ниже 5 версии: `brew services start mongodb-community@5.0`.

Компиляция из TypeScript в JavaScript:
- `npm install`
- `npm run build`

Запуск тестов:
- `npm run test-parser`
- `npm run test-specification`

## Этап оптимизации

Он выглядит лишним, но без него результат выполнения формул отличается от того, что возвращает монга.

Выражение в монге выполняется в 2 этапа - оптимизация и выполнение, и на этапе оптимизации могут быть ошибки, которых не будет на этапе выполнения, и это поведение пришлось полностью воспроизводить на других платформах.

### Пример

Выражение `[] + null` бросает ошибку на этапе оптимизации, в то время как выражение `[] + var1` со значением `var1` равным `null`  ошибку не бросает.

То есть наличие ошибки может зависеть от того, может ли монга оптимизировать выражение. 

## Формат ошибок

Текстовый формат ошибок следующий: `ЭТАП :: НОМЕР :: ПАРАМЕТРЫ`.

Этапы у нас следующие:

- parse: Этап чтения синтаксиса парсером
- validate: Этап инициации, проверка всего дерева
- optimize: Этап оптимизации
- evaluate: Этап выполнения
- convert: Этап преобразования формулы в формат монги
- finalize: Этап финального преобразования к нужному типу

Код ошибки это просто условное обозначение ошибки, по которому проще будет делать локализацию.

Например если суммировать неправильные типы, монга кидает ошибку "$add only supports numeric or date types, not %type%", у нас это add1.

А тот самый %type% из ошибки передается параметром. Параметр может отсутствовать.

Таким образом ошибка монги `Failed to optimize pipeline :: caused by :: $add only supports numeric or date types, not string` превращается в `optimize :: add1 :: string`, универсальные для всех платформ.

## Приоритеты бинарных операторов 

1. `??` (11)
2. `*`, `/`, `%` (10)
3. `+`, `-`, (9)
4. `&` (8)
5. `<`, `>`, `>=`, `<=`, `in` (7)
6. `==`, `!=` (6)
7. `and` (2)
8. `or` (1)

Все операторы лево-ассоциативны, кроме `??`, который право-ассоциативный.

## Добавление функций

1. Добавить функцию в PHP, JS
2. Добавить тесты в specification.test.js
3. Добавить название функции в utils.functions

## Выполнение с ограничениями

- LIMIT_MODE_NONE - Режим без ограничений по выполнению
- LIMIT_MODE_10K - Выполнение ограничено 10 000 вызовами функций
- LIMIT_MODE_1M - Выполнение ограничено 1 000 000 вызовов функций

## Известные проблемы

- Преобразование в строку больших чисел с дробью (как 120000000000.1234) по разному делается на разных платформах
- Преобразование числа 6.02214129e23 в монге с потерей точности делается
- В монге выход за границы TIMESTAMP_RANGE в операциях +/- не отслеживается, а добавлять целый слой проверки результатов в простые математические операции пока не хочется. Поэтому в арифметических операциях с датой и очень большими числами поведение формул может отличаться.
- range(1, 10000000) приводит к ошибке на MongoDB и PHP, но не в NodeJS 